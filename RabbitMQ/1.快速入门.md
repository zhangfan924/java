<h1 align="center">RabbitMQ快速上手以及核心概念详解</h1>

<p align="center">
  <img src="https://img.shields.io/badge/Markdown-模板-blue.svg" />
  <img src="https://img.shields.io/badge/Version-1.0-green.svg" />
</p>

# 📚一、MQ介绍

## 📘 1、什么是MQ，有什么用

 💡 **MQ（Message Queue，消息队列）**
 RabbitMQ 就是一种典型的 MQ 产品。要理解 MQ，可以从两个关键词来拆分：

- **Message（消息）**：在不同应用程序之间传递的数据。
- **Queue（队列）**：一种先进先出（FIFO）的数据结构，用来存储消息。

👉 **把消息放进队列，再在不同的应用程序之间传递，就形成了 Message Queue。**

首先搭建一个普通的Maven项目，在pom.xml中引入SpringBoot的依赖：

```xml
 <dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
		<version>2.4.5</version>
    </dependency>
</dependencies>
```

然后增加一个监听器类

```java
public class MyApplicationListener implements ApplicationListener<ApplicationEvent> {
    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        System.out.println("=====> MyApplicationListener: "+applicationEvent);
    }
}
```

接下来，添加一个SpringBoot启动类。在启动类中加入自己的这个监听器。

```java
@SpringBootApplication
public class AppDemo implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(AppDemo.class);
        application.addListeners(new MyApplicationListener());
        application.run(args);
    }

    @Resource
    private ApplicationContext applicationContext;
    @Override
    public void run(String... args) throws Exception {
        applicationContext.publishEvent(new ApplicationEvent("myEvent"){
        });
    }
}
```

好了。不用添加配置文件，直接启动就行。 然后可以看到这样的结果：

![QQ_1721910851913](img\QQ_1721910851913.png)

🚀 在 Spring Boot 启动过程中，框架会不断发布各种 **ApplicationEvent 事件**，用于标记当前启动到了哪个步骤。

- 在这个场景下，Spring Boot 就扮演了 **消息生产者（Producer）** 的角色。
- 每当有事件发布时，就会触发 **MyApplicationListener** 来处理，这个监听器就是 **消息消费者（Consumer）**。

⚡ **事件驱动（Event-Driven）**：
 常见的 `Controller` 示例就是如此，只有当外部请求触发时，方法才会被调用。

🌐 **消息驱动（Message-Driven）**：
 Producer 不依赖 Consumer 的存在，Consumer 也不依赖 Producer 的实时触发，二者通过消息来解耦。

📦 从这个例子我们可以看出：
 Spring Boot 内部已经集成了消息驱动机制，但它的 Producer 和 Consumer **只能在同一个进程中使用**。

❓如果需要 **跨进程**，甚至 **跨服务** 的消息传递怎么办？
🗂这时就需要一个独立的中间服务来负责消息的转发与存储 —— 这就是 **MQ 中间件**。

比如在一个大型电商项目中，订单服务完成下单，就可以发布下单事件，而下游的消费者，就可以消费这个下单事件，进行一些补充的业务。

![QQ_1721911943267](img\QQ_1721911943267.png)

### 🔗 1. 解耦（Decoupling）

- Producer 和 Consumer **只需与 MQ 中间件交互**，彼此之间没有直接依赖。
- Producer 不必关心有没有 Consumer、数量多少。
- Consumer 也不必关心消息是从哪里来的。
- ✅ 即便 Producer 和 Consumer 用不同语言开发，只要支持 MQ 协议，就能顺畅通信。

### ⏳ 2. 异步（Asynchronous）

- 消息发送后，先存储在 MQ 中间件里，而不是立刻交由 Consumer 处理。
- Consumer 可以 **随时启动**，再去中间件里消费消息。
- ✅ 这样就错开了 Producer 与 Consumer 的时间要求，提高了系统的灵活性。

### 📉 3. 削峰填谷（Load Shaving & Leveling）

- 当 Producer 发送消息过快，而 Consumer 处理能力有限时，MQ 可以 **暂存消息**。
- ✅ 这样能平滑高峰流量，避免 Consumer 被瞬时压力“压垮”。

---

## ✨ 2、主流MQ产品对比

|          | 优点                                   | 缺点                                                | 适用场景                     |
| :------- | :------------------------------------- | :-------------------------------------------------- | :--------------------------- |
| Kafka    | 吞吐量非常大，性能非常好，技术生态完整 | 功能比较单一                                        | 分布式日志收集，大数据采集   |
| RabbitMQ | 消息可靠性高，功能全面                 | 吞吐量较低。消息积压会影响性能。 erlang语言比较小众 | 企业内部系统调用             |
| RocketMQ | 高吞吐、高性能、高可用，高级功能非常全 | 技术生态相对没有那么完整                            | 几乎全场景。尤其适合金融场景 |

> 好的产品都是在不断演进的，所以对这些产品的理解也需要与时俱进。比如现在还有个MQ产品Pulsar，非常适合于大型企业内部海量的系统调用，也体现了非常强大的竞争力。

---

# 💡 二、RabbitMQ快速上手

## 🎯 1、RabbitMQ产品介绍

RabbitMQ的历史可以追随到2005年，他是一个非常老牌的MQ产品，使用非常广泛。同时期的很多MQ产品都已经逐渐被业界淘汰了，比如2003年诞生的ActiveMQ，2012年诞生的ZeroMQ，但是RabbitMQ却依然稳稳占据一席之地，足可见他的经典。官网地址 https://www.rabbitmq.com/ 。

目前最新的官网是这样介绍的：

![QQ_1721915032617](img\QQ_1721915032617.png)

## ⚠️ 2、安装RabbitMQ

### 📖 1、前置环境

我们这次选择的RabbitMQ版本是目前最新的3.13版本。其实就RabbitMQ最近的几个版本，核心的Quorum Queue 和 Stream Queue功能早在3.9.x版本就已经成型了。后续的版本主要是对这两个核心功能做一些修复以及增强，同时增加了很多新的功能插件。

RabbitMQ是基于Erlang语言开发的，所以安装RabbitMQ之前需要安装Erlang语言环境。需要注意下的是RabbitMQ与Erlang语言之间是有版本对应关系的。目前3.13版本的RabbitMQ需要Erlang语言版本26.0到26.2.x之间。

![QQ_1721915692469](img\QQ_1721915692469.png)

需要先从官网下载操作系统对应的RabbitMQ安装包以及Erlang语言的安装包。

### 🔧 2、安装RabbitMQ服务

RabbitMQ服务有多种安装方式。但是在学习阶段，建议大家使用CentOS手动进行安装。这样更能接触产品的细节。之后使用其他操作系统或者使用Docker等技术安装时，才会更顺利。

需要注意的是，当前版本的RabbitMQ建议CentOS版本最好升级到CentOS9版本。至少不能低于CentOS8。

Erlang语言包的安装，建议使用RabbitMQ提供的zero dependency版本。下载地址：[https://github.com/rabbitmq/erlang-rpm/releases](http:)

```bash
[root@192-168-65-112 ~]# rpm -ivh erlang-26.2.5.2-1.el9.x86_64.rpm 
警告：erlang-26.2.5.2-1.el9.x86_64.rpm: 头V4 RSA/SHA256 Signature, 密钥 ID 6026dfca: NOKEY
Verifying...                          ################################# [100%]
准备中...                          ################################# [100%]
正在升级/安装...
   1:erlang-26.2.5.2-1.el9            ################################# [100%]

[root@192-168-65-112 ~]# erl -version
Erlang (SMP,ASYNC_THREADS) (BEAM) emulator version 14.2.5.2
```

接下来安装RabbitMQ。这里我们采用RPM安装包的方式。安装包下载地址：https://github.com/rabbitmq/rabbitmq-server/releases 。 这里我们下载无依赖版本： rabbitmq-server-3.13.6-1.el8.noarch.rpm

```bash
[root@192-168-65-112 ~]# rpm -ivh rabbitmq-server-3.13.6-1.el8.noarch.rpm 
警告：rabbitmq-server-3.13.6-1.el8.noarch.rpm: 头V4 RSA/SHA512 Signature, 密钥 ID 6026dfca: NOKEY
Verifying...                          ################################# [100%]
准备中...                          ################################# [100%]
正在升级/安装...
   1:rabbitmq-server-3.13.6-1.el8     ################################# [100%]
/usr/lib/tmpfiles.d/rabbitmq-server.conf:1: Line references path below legacy directory /var/run/, updating /var/run/rabbitmq → /run/rabbitmq; please update the tmpfiles.d/ drop-in file accordingly.
```

安装完成后，可以使用几个常用的指令维护RabbitMQ的服务状态。

```bash
service rabbitmq-server start --启动Rabbitmq服务。启动应用之前要先启动服务。

rabbitmq-server -deched  --后台启动RabbitMQ应用 

rabbitmqctl start_app  --启动Rabbitmq

rabbitmqctl stop  --关闭Rabbitmq 

rabbitmqctl status -- 查看RabbitMQ服务状态。
出现Status为Runtime表示启动成功。
```

默认情况下， RabbitMQ只是一个后台服务，不便于管理。而RabbitMQ提供了管理插件，可以使用图形化的方式管理RabbitMQ。

```
[root@192-168-65-112 ~]# rabbitmq-plugins enable rabbitmq_management
Enabling plugins on node rabbit@192-168-65-112:
rabbitmq_management
The following plugins have been configured:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@192-168-65-112...
The following plugins have been enabled:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch

set 3 plugins.
Offline change; changes will take effect at broker restart.

--重启服务后生效
service rabbitmq-server start
rabbitmqctl start_app
```

插件激活后，就可以访问RabbitMQ的Web控制台了。访问端口15672.

![QQ_1721916642419](img\QQ_1721916642419.png)

RabbitMQ提供了默认的用户名guest，密码guest。但是默认情况下，只允许本地登录，远程访问是无法登录的。

这时，通常都会创建一个管理员账号单独对RabbitMQ进行管理。

```bash
[root@192-168-65-112 ~]# rabbitmqctl add_user admin admin
Adding user "admin" ...
Done. Don't forget to grant the user permissions to some virtual hosts! See 'rabbitmqctl help set_permissions' to learn more.
[root@192-168-65-112 ~]# rabbitmqctl set_permissions -p / admin "." "." ".*"
Setting permissions for user "admin" in vhost "/" ...
[root@192-168-65-112 ~]# rabbitmqctl set_user_tags admin administrator
Setting tags for user "admin" to [administrator] ...
```

这样就可以用admin/admin用户登录Web控制台了。

### 🔐 3、RabbitMQ基础使用

登录控制台后上方就能看到RabbitMQ的主要功能。其中Overview是概述，主要展示RabbitMQ服务的一些整体运行情况。后面Conections、Channels、Exchanges和Queues就是RabbitMQ的核心功能。最后的Admin则是一些管理功能。

例如我们之前创建的admin用户，就表现在Admin下的用户信息中。

![QQ_1721916904053](img\QQ_1721916904053.png)

例如，在Admin管理页面，可以创建一个虚拟机，virtual hosts，并配置admin用户拥有访问的权限。

![QQ_1721917035341](img\QQ_1721917035341.png)

#### 1、理解Queue

Exchange和Queue是RabbitMQ中用来传递消息的核心组件。我们可以简单体验一下。

![QQ_1721917323545](img\QQ_1721917323545.png)

创建完成后，选择这个test1队列，就可以在页面上直接发送消息以及消费消息了。

![QQ_1721917425690](img\QQ_1721917425690.png)

在RabbitMQ中的消息都是通过Queue队列传递的，这个Queue其实就是一个典型的FIFO的队列数据结构。我们当前的演示是通过控制台页面来通过Queue进行收发消息。未来，我们编写客户端时，就是绑定对应的对列进行消息收发。

#### 2、理解Exchange

队列Queue即可以发消息，也可以收消息，那旁边的Exchange交换机是干什么的呢？Exchange与Queue之间会建立一种绑定关系，通过绑定关系，Exchange交换机里发送的消息就可以分发到不同的Queue上。

进入Exchanges菜单，可以看到针对每个虚拟机，RabbitMQ都预先创建了多个Exchange交换机。

![QQ_1721917670101](img\QQ_1721917670101.png)

这里我们选择amq.direct交换机，进入交换机详情页，选择Binding，并将test1队列绑定到这个交换机上。

> 注意选择/mirror虚拟机上的Exchange

![QQ_1721917714896](img\QQ_1721917714896.png)

绑定完成后，可以在Exchange详情页以及Queue详情页都看到绑定的结果。

![QQ_1721917818310](img\QQ_1721917818310.png)

接下来就可以在Exchange的详情页里发送消息。然后在test1这个queue里就能消费到这条消息。

![QQ_1721917899024](img\QQ_1721917899024.png)

📌 **Exchange 并不存储消息**，它的作用是：

- 接收生产者发送的消息。
- 根据绑定关系和规则，把消息转发到相应的队列（Queue）中。

👉 因此：

- **生产者（Producer）** 需要与 Exchange 打交道。
- **消费者（Consumer）** 不必关心 Exchange，只需从 **Queue** 里取消息。

✨ 一个 Exchange 可以：

- 绑定 **一个队列**；
- 也可以绑定 **多个队列**。

在实际应用中，Exchange 和 Queue 之间可以建立 **不同类型的绑定关系**。

- 这些绑定关系决定了消息该转发到哪些队列。
- 在这个过程中，消息的 **Routing Key、Headers、Properties** 等参数就会起作用。

---

#### 3、理解Connection和Channel

这两个功能实际上是跟客户端应用的对应关系。一个Connection可以理解为一个客户端应用。而一个应用可以创建多个Channel，用来与RabbitMQ进行交互。

我们可以来搭建一个客户端应用了解一下。

1、创建一个Maven项目，在pom.xml中引入RabbitMQ客户端的依赖：

```xm
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.21.0</version>
</dependency>
```

2、然后就可以创建一个消费者实例，尝试从RabbitMQ上的test1这个队列上拉取消息。

```java
public class FirstConsumer {
    private static final String HOST_NAME="192.168.65.112";
    private static final int HOST_PORT=5672;
    private static final String QUEUE_NAME="test2";
    public static final String USER_NAME="admin";
    public static final String PASSWORD="admin";
    public static final String VIRTUAL_HOST="/mirror";

    public static void main(String[] args) throws Exception{
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(HOST_NAME);
        factory.setPort(HOST_PORT);
        factory.setUsername(USER_NAME);
        factory.setPassword(PASSWORD);
        factory.setVirtualHost(VIRTUAL_HOST);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        /**
         * 声明一个对列。几个参数依次为： 队列名，durable是否实例化；exclusive：是否独占；autoDelete：是否自动删除；arguments:参数
         * 这几个参数跟创建队列的页面是一致的。
         * 如果Broker上没有队列，那么就会自动创建队列。
         * 但是如果Broker上已经由了这个队列。那么队列的属性必须匹配，否则会报错。
         */
        channel.queueDeclare(QUEUE_NAME, true, false, false, null);
        //每个worker同时最多只处理一个消息
        channel.basicQos(1);
        //回调函数，处理接收到的消息
        Consumer myconsumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body)
                    throws IOException {
                System.out.println("========================");
                String routingKey = envelope.getRoutingKey();
                System.out.println("routingKey >"+routingKey);
                String contentType = properties.getContentType();
                System.out.println("contentType >"+contentType);
                long deliveryTag = envelope.getDeliveryTag();
                System.out.println("deliveryTag >"+deliveryTag);
                System.out.println("content:"+new String(body,"UTF-8"));
                // (process the message components here ...)
                channel.basicAck(deliveryTag, false);
            }
        };
        //从test1队列接收消息
        channel.basicConsume(QUEUE_NAME, myconsumer);
    }
}
```

> 暂时不用过多纠结于实现细节，注意梳理整体实现流程。

执行这个应用程序后，就会在RabbitMQ上新创建一个test2的队列(如果你之前没有创建过的话)，并且启动一个消费者，处理test2队列上的消息。这时，我们可以从管理平台页面上往test2队列发送一条消息，这个消费者程序就会及时消费消息。

![QQ_1722144626462](img\QQ_1722144626462.png)

然后在管理平台的Connections和Channels里就能看到这个消费者程序与RabbitMQ建立的一个Connection连接与一个Channel通道。

![QQ_1722144651898](img\QQ_1722144651898.png)

这里可以看到Connection就是与客户端的一个连接。只要连接还通着，他的状态就是running。而Channel是RabbitMQ与客户端进行数据交互的一个通道，没有数据交互时，状态就是idle闲置。有数据交互时，就会变成running。在他们后面，都会展示出数据交互的状态。

另外，从这个简单示例中可以看到，Channel是从Connection中创建出来的，这也意味着，一个Connection中可以创建出多个Channel。从这些Connection和Channel中可以很方面的了解到RabbitMQ当前的服务运行状态。

#### 4、Virtual Host（虚拟主机）的概念

- 一个 **Virtual Host（简称 vhost）** 就像是 RabbitMQ 中的一个 **逻辑隔离空间**。
- 每个 vhost 里面可以有自己独立的 **队列（Queue）**、**交换机（Exchange）** 和 **绑定关系（Binding）**。
- 不同 vhost 之间完全隔离，互不影响，相当于在一个 RabbitMQ 服务里开了多个“小的消息队列系统”。

🔑 **作用**

1. **资源隔离**
    比如一个公司里有多个项目：电商、支付、日志，可以分别放在不同的 vhost 里，避免消息队列混乱。
2. **权限控制**
    用户在 RabbitMQ 中的权限是基于 vhost 来设置的。
   - 用户 `admin` 可以访问 `/`（默认 vhost）
   - 用户 `order_user` 只能访问 `/order` 这个 vhost
      这样就能精细化管理权限。
3. **多租户支持**
    类似于云服务里不同租户（tenant），一个 RabbitMQ 实例就能支持多个业务组同时使用。

# ✨ 三、RabbitMQ中的核心概念总结

![QQ_1722144719705](img\QQ_1722144719705.png)

## 1️⃣ Queue（队列）

📌 RabbitMQ 中最核心的概念。

- **作用**：消息真正的存储单元。
- **特性**：天然具备 FIFO（先进先出）的顺序。
- **流程**：消息最终进入 Queue → 消费者从 Queue 里取出并处理。

------

## 2️⃣ Exchange（交换机）

📌 RabbitMQ 的消息路由器。

- **作用**：不存储消息，只负责“分发”。
- **原理**：
  - Producer 把消息发到 Exchange
  - Exchange 按绑定关系转发到 Queue
- **特点**：Exchange 并不是必须的，但大多数业务场景都会用到（Direct、Fanout、Topic、Headers 等类型）。

------

## 3️⃣ Virtual Host（虚拟主机）

📌 RabbitMQ 的“多租户”机制。

- **作用**：在一个 RabbitMQ 集群中，可以划分多个虚拟主机。
- **特点**：
  - 每个 Virtual Host 都有自己的一整套组件（Queue、Exchange、Binding 等）。
  - 可以单独配置权限与资源。
  - **完全隔离**：不同 Virtual Host 之间不能直接通信。
- **类比**：就像在一台服务器上运行多个独立的 RabbitMQ 实例。

------

## 4️⃣ Connection（连接）

📌 客户端与 RabbitMQ 建立的 **TCP 连接**。

- 建立连接是第一步。
- 用完必须关闭，释放资源。
- **注意**：Connection 属于重量级对象，不要频繁创建和销毁。

------

## 5️⃣ Channel（信道）

📌 AMQP 协议层面真正的通信通道。

- **关系**：一个 Connection 可以包含多个 Channel。
- **特点**：
  - 每个 Channel 有唯一 ID。
  - 大部分操作（发送消息、消费消息）都在 Channel 层面完成。
  - 复用 Connection 的 TCP 通道，性能开销更小。
- **最佳实践**：一个应用通常维护少量 Connection，但会为不同线程开多个 Channel。
