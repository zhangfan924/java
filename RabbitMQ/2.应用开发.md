<h1 align="center">RabbitMQ客户端应用开发实战</h1>

<p align="center">
  <img src="https://img.shields.io/badge/Markdown-模板-blue.svg" />
  <img src="https://img.shields.io/badge/Version-1.0-green.svg" />
</p>

# 一、回顾RabbitMQ基础概念

![QQ_1722144719705](img\QQ_1722144719705.png)

这个RabbitMQ的核心组件，是进行应用开发的基础。

# 二、RabbitMQ基础编程模型

RabbitMQ提供了很多种主流编程语言的客户端支持。这里我们只分析Java语言的客户端。

上一章节提供了一个简单的RabbitMQ客户端实现，这里，就以上一章节的客户端示例为基础，了解下RabbitMQ客户端开发的基础流程，为后续理解各种业务场景打下基础。

## 1、maven依赖

```xml
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.21.0</version>
</dependency>
```

amqp是一种标准的消息驱动实现协议，RabbitMQ是对这一协议的具体实现。由于协议具有稳定性，所以，通常RabbitMQ的客户端不一定要求与服务端版本一致。

## 2、基础编程模型

结合上一章节的第一个案例，详细拆解每个核心概念的具体实现方式以及功能扩展。

### step1、首先创建连接，获取Channel

```java
ConnectionFactory factory = new ConnectionFactory();
factory.setHost(HOST_NAME);
factory.setPort(HOST_PORT);
factory.setUsername(USER_NAME);
factory.setPassword(PASSWORD);
factory.setVirtualHost(VIRTUAL_HOST);
Connection connection = factory.newConnection();
Channel channel = connection.createChannel();
```

通常情况下，我们在一个客户端里都只是创建一个Channel就可以了，因为一个Channel只要不关闭，是可以一直复用的。但是，如果你想要创建多个Channel，要注意一下Channel冲突的问题。

在创建channel时，可以在createChannel方法中传入一个分配的int参数channelNumber。这个ChannelNumber就会作为Channel的唯一标识。而RabbitMQ防止ChannelNumber重复的方式是：如果对应的Channel没有创建过，就会创建一个新的Channel。但是如果ChannelNumber已经创建过一个Channel了，这时就会返回一个null。

### ❓ 什么情况下会创建多个 Channel？

通常在客户端里，**一个 Channel 就够用**，因为：

- Channel 是轻量级的，
- 一个 Channel 可以复用进行多个操作（声明队列、发送、消费）。

但是在某些场景下，**需要创建多个 Channel**：

------

#### 1️⃣ 多线程并发场景

- **原因**：RabbitMQ 的 **Channel 不是线程安全的**。
- 如果在多线程环境下共享一个 Channel，可能会发生数据错乱或死锁。
- ✅ 正确做法：每个线程单独创建一个 Channel，这样互不干扰。

------

#### 2️⃣ 区分生产者与消费者的逻辑

- 有些应用同时承担 **生产者** 和 **消费者** 的角色。
- 为了避免逻辑耦合和资源争用，可以：
  - 一个 Channel 专门用于生产消息
  - 一个 Channel 专门用于消费消息

------

#### 3️⃣ 业务隔离 / 优先级控制

- 在一些复杂业务里，不同类型的消息要分开处理：
  - 例如：订单消息、日志消息、延时任务
- 可以用不同的 Channel 来操作不同的 Queue，方便做流量隔离或监控。

------

#### 4️⃣ 短连接/临时任务

- 某些临时任务只需和 RabbitMQ 打一次交道，不想复用已有 Channel。
- 这时可以新建一个 Channel，用完就关闭，避免影响长期运行的 Channel。

### step2、声明Exchange

关键代码：

```java
channel.exchangeDeclare(String exchange, String type, boolean durable, boolean autoDelete,Map<String, Object> arguments) throws IOException;
```

> ### 各参数含义
>
> | 参数         | 说明                                                     |
> | ------------ | -------------------------------------------------------- |
> | `exchange`   | 交换机名字，可以自己定义，最好唯一                       |
> | `type`       | 交换机类型（四种类型：direct、fanout、topic、headers）   |
> | `durable`    | 是否持久化，如果为 `true`，RabbitMQ 重启后交换机不会消失 |
> | `autoDelete` | 是否自动删除，当没有队列绑定时，交换机会被删除           |
> | `arguments`  | 扩展属性，通常用于自定义特性（比如消息 TTL、死信队列等） |

1. 如果 Broker 上不存在该 Exchange，会自动创建新的。
2. 如果 Broker 上已经有该 Exchange，声明时的参数必须**完全一致**，否则会报错。
3. 管理控制台上可以看到这些参数，尤其是 type、durable 等，最好对照控制台。

![QQ_1722151145975](img\QQ_1722151145975.png)



### step3、声明queue

关键代码：

```java
 channel.queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments);
```

> ### 各参数含义
>
> | 参数         | 说明                                             |
> | ------------ | ------------------------------------------------ |
> | `queue`      | 队列名称                                         |
> | `durable`    | 是否持久化队列（重启 RabbitMQ 不丢失队列和消息） |
> | `exclusive`  | 是否为独占队列，只能被创建它的 Connection 使用   |
> | `autoDelete` | 是否自动删除，当没有消费者时队列自动删除         |
> | `arguments`  | 扩展属性（可定义队列类型、消息 TTL 等）          |

1. 队列不存在时，会自动创建。
2. 队列已存在时，声明属性必须与已有队列一致，否则报错。
3. Durability 决定消息是否写入磁盘：
   - **持久化** (`durable = true`)：重启不丢失，但性能稍低
   - **临时** (`durable = false`)：重启会丢失，但性能高
4. 队列类型：
   - API 默认创建 **Classic 类型**
   - 如果要声明 **Quorum 类型**，需要通过 `arguments.put("x-queue-type", "quorum")` 来指定
   - 不同类型队列参数可能不同，例如 Quorum 队列默认持久化，不支持 Durability 参数

![QQ_1722151378827](img\QQ_1722151378827.png)





#### ❓ Quorum 队列是什么

##### 1️⃣ 什么是 Quorum 队列

Quorum 队列是 RabbitMQ 3.8 之后引入的一种 **高可用、强一致性的队列类型**。它是基于 **Raft 协议** 实现的分布式队列，设计目标是：

- 消息 **不会丢失**
- 集群节点发生故障时，能够 **自动恢复**
- 支持 **数据复制和一致性**

换句话说，Quorum 队列就是为了保证在多节点集群中 **消息安全可靠** 的队列类型。

------

##### 2️⃣ Quorum 队列的内部原理

- 每个 Quorum 队列都有 **多个副本（replica）**，通常在多个节点上分布。
- **一个副本为 Leader**，其他为 Follower。
- 所有写操作（发送消息）必须在 **大多数节点（majority）** 上成功确认，才算成功。
- 当 Leader 节点宕机时，Follower 会选举新的 Leader，队列继续可用。

> ⚡ 核心思想：基于 Raft 协议，保证写入数据一致性和高可用。

#### ❓ Stream 队列是什么

##### 1️⃣ 什么是 Stream 队列

- **Stream 队列** 是一种 **持久化、高吞吐量、面向顺序消息**的队列类型。
- 它的核心目标是：**在保证顺序的情况下，处理海量消息，并支持消息按偏移量（offset）读取**。
- 可以理解成 RabbitMQ 对 **Kafka 风格日志队列** 的支持。

> 🔹 Quorum 队列强调一致性和高可靠性
>  🔹 Stream 队列强调顺序性和高吞吐量

------

##### 2️⃣ Stream 队列的内部原理

- Stream 队列将消息 **追加写入磁盘文件**（像日志一样），而不是像 Classic 或 Quorum 队列那样直接存储在内存里。
- 消息 **按顺序存储**，每条消息都有唯一的 **offset**。
- 消费者可以 **从任意 offset** 读取消息，也可以重复消费。
- 支持 **批量拉取（batch fetch）**，提高吞吐量。
- 默认 **持久化**，即使服务重启也不会丢消息。

#### 三种队列对比

| 特性     | Classic 队列               | Quorum 队列        | Stream 队列                    |
| -------- | -------------------------- | ------------------ | ------------------------------ |
| 持久化   | 可选                       | 默认持久化         | 默认持久化                     |
| 消息顺序 | FIFO，但可能因副本同步乱序 | FIFO，Raft保证顺序 | FIFO，严格顺序                 |
| 高可用性 | 可配置镜像                 | Raft多副本         | 通过集群复制实现               |
| 消息消费 | 推模式                     | 推模式             | 拉模式（Pull）为主，可重复消费 |
| 吞吐量   | 高                         | 中                 | 很高（百万级/秒）              |
| 消息存储 | 内存+磁盘                  | 内存+磁盘          | 磁盘日志式，适合大消息量       |

### step4、声明Exchange与Queue的绑定关系

```java
channel.basicPublish(String exchange, String routingKey, BasicProperties props,message.getBytes("UTF-8")) ;
```

> ### 参数说明
>
> | 参数         | 作用                                         |
> | ------------ | -------------------------------------------- |
> | `queue`      | 要绑定的队列名称                             |
> | `exchange`   | 要绑定的交换机名称                           |
> | `routingKey` | 路由关键字，用于 Exchange 决定消息的分发逻辑 |
> | `返回值`     | Binding-confirm，确认绑定成功                |
> | `异常`       | IOException，如果绑定失败                    |

**Broker 自动创建**

- 如果 Queue、Exchange 已经存在，但 Binding 不存在，RabbitMQ 会自动创建。
- 如果 Binding 已经存在，声明时必须与现有 Binding 属性一致，否则报错。

**routingKey 的作用**

- 不同类型的 Exchange（Direct / Topic / Fanout / Headers）对 routingKey 的使用规则不同：
  - **Direct Exchange**：routingKey 必须完全匹配 Queue。
  - **Topic Exchange**：支持通配符，如 `user.*` 或 `#.log`。
  - **Fanout Exchange**：忽略 routingKey，广播给所有绑定的 Queue。
  - **Headers Exchange**：通常用属性（props）匹配，不使用 routingKey。

**多 Binding**

- 一个 Exchange 可以绑定多个 Queue。
- 一个 Queue 也可以绑定多个 Exchange（同一个 routingKey 或不同 routingKey）。

### step5、Producer根据应用场景发送消息到queue

```
channel.basicPublish(String exchange, String routingKey, BasicProperties props,message.getBytes("UTF-8")) ;
```

> ### 参数说明
>
> | 参数         | 作用                                                         |
> | ------------ | ------------------------------------------------------------ |
> | `exchange`   | 消息要发送到的交换机名称。如果不使用 Exchange，可传空字符串 `""`，表示默认交换机（Default Exchange）。 |
> | `routingKey` | 路由关键字，用于 Exchange 决定消息该发到哪个 Queue。不同 Exchange 类型匹配规则不同。 |
> | `props`      | 消息属性（AMQP.BasicProperties），可设置持久化、消息类型、优先级、headers 等。 |
> | `body`       | 消息体，字节数组，一般用 `message.getBytes("UTF-8")` 转换。  |

**Exchange 必须存在**

- 如果发送到一个不存在的 Exchange，会触发 **channel-level protocol exception**，导致 Channel 被关闭。

**routingKey 的作用**

- 和 Exchange 类型紧密相关：
  - **Direct Exchange**：完全匹配 Queue 的 bindingKey。
  - **Topic Exchange**：支持通配符匹配，如 `user.*`。
  - **Fanout Exchange**：忽略 routingKey，广播消息。
  - **Headers Exchange**：通常使用 props 中的 header 属性匹配，不使用 routingKey。

**props 的作用**

- 可以控制消息的持久化（deliveryMode）、优先级（priority）、过期时间（expiration）、消息类型（type）、headers 等。
- 不用死记，管理控制台或 API 文档里有详细说明。

**默认交换机（Default Exchange）**

- RabbitMQ 内置一个空字符串 Exchange。
- 如果 `exchange=""`，则 routingKey 必须是存在的 Queue 名称，消息会直接发送到指定 Queue。![QQ_1722152570982](img\QQ_1722152570982.png)

props的这些配置项，可以用RabbitMQ中提供的一个Builder对象来构建。

```java
    AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder(); 
    //对应页面上的Properties部分，传入一些预定的参数值。
    builder.deliveryMode(MessageProperties.PERSISTENT_TEXT_PLAIN.getDeliveryMode());
    builder.priority(MessageProperties.PERSISTENT_TEXT_PLAIN.getPriority());
    //builder.headers(headers);对应页面上的Headers部分。传入自定义的参数值
    builder.build()
    AMQP.BasicProperties prop = builder.build();
```

在发送消息时要注意一下消息的持久化问题。MessageProperties.PERSISTENT_TEXT_PLAIN是RabbitMQ提供的持久化消息的默认配置。而RabbitMQ中消息是否持久化不光取决于消息，还取决于Queue。通常为了保证消息安全，会将Queue和消息同时声明为持久化。

### step6、Consumer消费消息

定义消费者，消费消息进行处理，并向RabbitMQ进行消息确认。确认了之后就表明这个消息已经消费完了，否则RabbitMQ还会继续发起重试。

#### 1️⃣ 消费者的核心作用

Consumer 的职责就是：

1. 从 **Queue** 获取消息
2. 对消息进行处理
3. 向 RabbitMQ **确认消息已消费**（Ack）

> 如果消息未被确认，RabbitMQ 会认为消费失败，会重新投递消息给其他消费者或自己重试。

------

#### 2️⃣ 消费模式

##### (1) **Push 模式（推荐）**

- RabbitMQ **主动推送**消息给 Consumer
- 通常会在客户端启动一个线程或线程池，长时间挂起等待消息
- **优点**：消息处理及时，不需要频繁轮询，服务端负载小

**关键代码**：

```
channel.basicConsume(String queue, boolean autoAck, Consumer callback);
```

| 参数       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| `queue`    | 队列名称                                                     |
| `autoAck`  | 是否自动应答：`true`表示消息一到就自动确认，`false`表示手动确认 |
| `callback` | 消费者回调接口，处理收到的消息                               |

> 消息处理完后，如果 `autoAck=false`，需要调用 `channel.basicAck(deliveryTag, false)` 来显式确认消息。

------

##### (2) **Pull 模式**

- Consumer **主动拉取**消息
- 需要不断调用 `basicGet` 来查询消息
- **优点**：可以按需拉取，适合处理低频或批量处理
- **缺点**：不够实时，会增加服务端压力

**关键代码**：

```
GetResponse response = channel.basicGet(QUEUE_NAME, boolean autoAck);
```

| 参数         | 说明                                                       |
| ------------ | ---------------------------------------------------------- |
| `QUEUE_NAME` | 队列名称                                                   |
| `autoAck`    | 是否自动应答                                               |
| 返回值       | `GetResponse`，包含消息数据。如果队列为空，返回 `GetEmpty` |

> 同样，如果 `autoAck=false`，处理完消息后需要手动调用 `basicAck` 确认。

------

#### 3️⃣ 消息确认机制（Ack）

- **autoAck=true**
  - 消息一送到 Consumer 就自动确认
  - 如果 Consumer 异常退出，消息可能丢失
- **autoAck=false**（推荐）
  - 消费者处理完消息后手动确认
  - `channel.basicAck(deliveryTag, false)`
  - Broker 收到 Ack 后，才会认为消息消费成功

> 实际生产中，推模式 + 手动 Ack 是最常用的组合。

### step7、完成以后关闭连接，释放资源

```java
channel.close(); 
conection.clouse();
```

用完之后主动释放资源。如果不主动释放的话，大部分情况下，过一段时间RabbitMQ也会将这些资源释放掉，但是这就需要额外消耗系统资源。

## 3、关于消息监听与回溯

上一节只是列出了用得最多的几个常用的方法。但是，RabbitMQ的客户端还提供了很多重载方法和扩展方法，这些需要自行掌握。

例如，在消费消息是，channel还提供了一个重载的方法：

```java
String basicConsume(String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback, ConsumerShutdownSignalCallback shutdownSignalCallback) throws IOException;
```

这些callback实际上就是RabbitMQ在Consumer中保留的业务扩展点。这些拓展的方法，学习的时候可能没有太大的作用。但是，如果你没有提前总结，等到真正开发的时候，肯定想不到这些扩展点。

另外，你也可以自己做一个小案例。

```java
public class CallbackConsumer {
    private static final String EXCHANGE_NAME="callbackExchange";
    private static final String ALTER_EXCHANGE_NAME="alterExchange";
    private static final String QUEUE_NAME = "callbackQueue";

    public static void main(String[] args) throws Exception {
        Connection connection = RabbitMQUtil.getConnection();
        Channel channel = connection.createChannel();
        Map<String,Object> params = new HashMap<>();
        params.put("alternate-exchange",ALTER_EXCHANGE_NAME);
        channel.exchangeDeclare(EXCHANGE_NAME,BuiltinExchangeType.DIRECT,true,false,params);
        channel.exchangeDeclare(ALTER_EXCHANGE_NAME,BuiltinExchangeType.DIRECT,true,false,null);

        channel.queueDeclare(QUEUE_NAME, true, false, false, null);

        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"key1");

        channel.basicConsume(QUEUE_NAME, new DeliverCallback() {
                    @Override
                    public void handle(String consumerTag, Delivery message) throws IOException {
                        long deliveryTag = message.getEnvelope().getDeliveryTag();
                        String correlationId = message.getProperties().getCorrelationId();
                        System.out.println("received message consumerTag: " + consumerTag + "; message: " + new String(message.getBody())+";deliveryTag: "+deliveryTag+";correlationId: "+correlationId);
                        channel.basicAck(deliveryTag,false);
                    }
                }
                //去控制台把队列删掉就会触发cancel
                , new CancelCallback() {
                    @Override
                    public void handle(String consumerTag) throws IOException {
                        System.out.println("canceled message consumerTag: " + consumerTag + "; ");
                    }
                }
                , new ConsumerShutdownSignalCallback() {
                    @Override
                    public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {
                        System.out.println("consumer shutdown message consumerTag: " + consumerTag + "; Exception: " + sig);
                    }
                });
    }
}
```

然后往队列里多次发送消息。你能看到这样的结果：

```
received message consumerTag: amq.ctag-6d_w_WZWpu66H61kzuUfTw; message: message;deliveryTag: 1
received message consumerTag: amq.ctag-6d_w_WZWpu66H61kzuUfTw; message: message;deliveryTag: 2
received message consumerTag: amq.ctag-6d_w_WZWpu66H61kzuUfTw; message: message;deliveryTag: 3
received message consumerTag: amq.ctag-6d_w_WZWpu66H61kzuUfTw; message: message;deliveryTag: 4
```

这些就是从DeliverCallback接口反应出来的结果。从这个结果你是否能理解之前没有详细分享的consumerTag和deliveryTag到底是什么东西？是的，**consumerTag代表的是与客户端的一个会话**。**deliveryTag代表的是这个Channel处理的一条消息**。这都是RabbitMQ服务端分配的一些内部参数。日后，如果你希望对Consumer处理的每一条消息增加溯源过功能时，把consumerTag+deliveryTag作为消息编号，保存下来，这就是一个不错的设计。

# 三、RabbitMQ常用的消息场景

![QQ_1722153617288](img\QQ_1722153617288.png)

## 1：hello world体验

![QQ_1722153789138](img\QQ_1722153789138.png)

最直接的方式，**P端发送一个消息到一个指定的queue，中间不需要任何exchange规则**。C端按queue方式进行消费。

关键代码：(其实关键的区别也就是几个声明上的不同。)

producer:

```java
channel.queueDeclare(QUEUE_NAME,false,false,false,null);
channel.basicPublish("", QUEUE_NAME, null, message.getBytes("UTF-8"));
```

consumer:

```
channel.queueDeclare(QUEUE_NAME, false, false, false, null);
```

## 2：Work queues 工作序列

这是RabbitMQ最基础也是最常用的一种工作机制。![QQ_1722153802670](img\QQ_1722153802670.png)

工作任务模式，领导部署一个任务，由下面的一个员工来处理。只关心任务被正确处理，不关心给谁处理。

**Producer消息发送给queue，多个Consumer同时往队列上消费消息。**

关键代码： ===》producer: 将消息直接到Queue上。

```java
channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); //任务一般是不能因为消息中间件的服务而被耽误的，所以durable设置成了true，这样，即使rabbitMQ服务断了，这个消息也不会消失
channel.basicPublish("", TASK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,
        message.getBytes("UTF-8"));
```

Consumer: 每次拉取一条消息。

```java
channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);
channel.basicQos(1);
channel.basicConsume(TASK_QUEUE_NAME, false, consumer);
```

### 4️⃣ 注意事项

#### ① 消息确认（Ack）

- **必须**手动确认每条消息
- 如果 Consumer 未 ack，服务端会 **重复投递消息**
- 未 ack 的消息会一直占用资源，可能造成 **Poison Message（毒消息）问题）**

------

#### ② 消息可靠性

- 即使队列和消息都设置 `durable=true`，也不能 **完全保证消息不丢失**
- 原因：
  - RabbitMQ 写入消息到 **PageCache**（内存缓存），并非立即写入磁盘
  - 系统断电可能导致 PageCache 数据丢失
- 解决方式：
  - 使用 **Publisher Confirms（发布确认机制）**
  - 通过应用层确保消息已安全写入 RabbitMQ

------

#### ③ 多个 Consumer 的消息分发

- 默认 **轮询（Round-Robin）** 分发，不考虑消费者处理速度
- 改进方案：
  - 设置 **`prefetchCount`**（通过 `basicQos(prefetchCount)`）
  - 表示消费者能同时处理的最大未 ack 消息数量
  - 超过这个值，服务端不会再给该消费者发送消息
  - 注意：如果所有消费者都达到上限，消息会阻塞在队列中，需要监控或扩容消费者

------

#### ④ 队列容量问题

- 如果所有消费者都忙，队列可能堆积
- 应对策略：
  - 增加消费者节点
  - 限制队列大小
  - 或者根据业务采取 **消息降级/拒绝策略**

## 3：Publish/Subscribe 订阅 发布 机制

type为**fanout** 的exchange：

![QQ_1722155082752](img\QQ_1722155082752.png)

### 1️⃣ 核心思想

- Producer **只负责发送消息给 Exchange**，不关心消息最终会被哪个 Queue 消费。
- Exchange 根据类型（这里是 **fanout**）将消息分发给所有与它绑定的队列。
- 每个 Queue 都可以有独立的 Consumer 消费消息。
- 这样实现了 **Producer 与 Consumer 的解耦**，Producer 不需要知道消费者的存在。

------

### 2️⃣ fanout Exchange 特性

- **类型**：`fanout`
- **消息分发**：
  - 不看 RoutingKey
  - 消息会广播到所有绑定到该 Exchange 的队列
- **适用场景**：
  - 需要一条消息被多个消费者同时处理的场景（比如广播通知、日志收集、实时数据推送）。

------

### 3️⃣ 关键代码分析

**Producer 端：**

```
channel.exchangeDeclare(EXCHANGE_NAME, "fanout");
channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("UTF-8"));
```

- 声明 Exchange（类型 fanout）
- 将消息发布到 Exchange
- RoutingKey 为空，因为 fanout 类型不使用它

**Consumer 端（绑定队列）：**

```
channel.exchangeDeclare(EXCHANGE_NAME, "fanout");
String queueName = channel.queueDeclare().getQueue(); // 临时队列
channel.queueBind(queueName, EXCHANGE_NAME, "");      // 绑定到 Exchange
```

- 每个 Consumer 都创建自己的队列（通常是临时队列）
- 将队列绑定到 Exchange
- Exchange 会把消息广播到所有绑定的队列

------

### 4️⃣ 区别于 Work Queue

| 特性         | Work Queue（工作队列）     | Publish/Subscribe（发布/订阅） |
| ------------ | -------------------------- | ------------------------------ |
| 消息消费情况 | 一条消息只被一个消费者处理 | 一条消息可以被多个消费者处理   |
| 消费者数量   | 可以多个，但只是分摊消息   | 可以多个，每个都能收到消息     |
| 目的         | 提高吞吐量、负载均衡       | 广播消息、解耦生产者和消费者   |

------

💡 **总结**：

- Fanout Exchange 是 **广播型**的，消息会发送给所有绑定队列。
- 每个消费者都有自己的队列，所以即使同一条消息，所有消费者都能收到。

## 4：Routing 基于内容的路由

type为”direct” 的exchange

![QQ_1722155228480](img\QQ_1722155228480.png)

这种模式一看图就清晰了。 在上一章 exchange 往所有队列发送消息的基础上，增加一个路由配置，指定exchange如何将不同类别的消息分发到不同的queue上。

关键代码===> Producer 同样是往Exchange发送消息，但是需要指定一个routingKey

```java
channel.exchangeDeclare(EXCHANGE_NAME, "direct");
channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes("UTF-8"));
```

Bindings 在建立Exchange和Queue的绑定关系时，需要指定routingKey。

```java
channel.exchangeDeclare(EXCHANGE_NAME, "direct");
channel.queueBind(queueName, EXCHANGE_NAME, routingKey1);
channel.queueBind(queueName, EXCHANGE_NAME, routingKey2);
channel.basicConsume(queueName, true, consumer);
```

消息就会根据routingkey转发到对应的Queue上，然后给消费者处理。

## 5：Topics 基于话题的路由

type为"topic" 的exchange

![QQ_1722155353494](img\QQ_1722155353494.png)

这个模式也就在Routing模式的基础上，对routingKey进行了模糊匹配。单词之间用,隔开，* 代表一个具体的单词。# 代表0个或多个单词。

关键代码===> Producer，依然是往Exchange发送消息，并且需要带上routingKey。

```java
channel.exchangeDeclare(EXCHANGE_NAME, "topic");
channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes("UTF-8"));
```

Bindings: 绑定routingKey

```java
channel.exchangeDeclare(EXCHANGE_NAME, "topic");
channel.queueBind(queueName, EXCHANGE_NAME, routingKey1);
channel.queueBind(queueName, EXCHANGE_NAME, routingKey2);
channel.basicConsume(queueName, true, consumer);
```

消息在根据routingKey进行转发时，会进行模糊匹配。

## 6：Publisher Confirms 发送者消息确认

### 1️⃣ 问题背景

- 默认情况下，Producer 调用 `basicPublish` **没有返回值**。
- 也就是说 Producer 并不知道消息是否真的成功到达 RabbitMQ Broker。
- 如果发送失败（网络中断、Broker 异常等），消息可能丢失。
- **解决方案**：开启 **发送者确认模式**（Publisher Confirms）。

------

### 2️⃣ 开启发送者确认模式

```
channel.confirmSelect();
```

- 必须在 Channel 上手动开启。
- 开启后，Broker 会在消息成功到达 Exchange 后给 Producer 返回确认（ack 或 nack）。

------

### 3️⃣ 三种确认策略

#### ① 单条消息确认

```
channel.basicPublish("", queue, null, body.getBytes());
channel.waitForConfirmsOrDie(5_000);
```

- 每发送一条消息就等待 Broker 确认。
- **优点**：简单、消息可靠性最高。
- **缺点**：**同步阻塞 Channel**，吞吐量低。
- 如果超过超时时间没有收到确认，会抛异常，可做重试或记录日志。

------

#### ② 批量消息确认

```java
int batchSize = 100;
int outstandingMessageCount = 0;

for (...) {
    channel.basicPublish("", queue, null, body.getBytes());
    outstandingMessageCount++;

    if (outstandingMessageCount == batchSize) {
        channel.waitForConfirmsOrDie(5_000);
        outstandingMessageCount = 0;
    }
}
if (outstandingMessageCount > 0) {
    channel.waitForConfirmsOrDie(5_000);
}
```

- 累计一批消息后再一起确认。
- **优点**：吞吐量比单条确认高。
- **缺点**：确认异常时，无法知道哪一条消息出错，只知道这一批失败。

------

#### ③ 异步确认

```java
channel.addConfirmListener(ackCallback, nackCallback);
```

- 注册 **ConfirmCallback**：

  ```java
  void handle(long sequenceNumber, boolean multiple)
  ```

  - `sequenceNumber`：消息唯一序列号，由 `channel.getNextPublishSeqNo()` 获取。
  - `multiple`：
    - `false` → 仅确认当前序列号的消息。
    - `true` → 确认该序列号及之前所有未确认的消息。

- **优点**：

  - 性能最好，异步处理。
  - 可以单独处理成功和失败消息。

- **缺点**：

  - 需要自己维护序列号与消息的映射关系。

------

### 4️⃣ 进一步保证消息不丢失

- **确认消息是否路由到 Queue**：
  - Publisher 可以注册 **ReturnListener**。
  - 监控消息是否从 Exchange 成功路由到 Queue。
  - 如果路由失败，可以通过 **alternate-exchange** 属性将消息转到兜底 Exchange。
- **总结**：
  1. **单条确认** → 简单可靠，但性能差
  2. **批量确认** → 性能好，但异常无法定位单条消息
  3. **异步确认** → 最优方案，性能高，可精确处理每条消息

## 7、Headers 头部路由机制

### 1️⃣ Headers 交换机概念

- **类型**：`BuiltinExchangeType.HEADERS`
- **特点**：
  - 消息路由 **不依赖 routingKey**。
  - 消息通过 **头信息（Headers）** 的键值对来匹配消费者。
  - 消费者在绑定队列时，可以指定对哪些头信息感兴趣。
- **匹配方式**：
  - `"x-match" = "all"` → 所有指定的头信息都必须匹配。
  - `"x-match" = "any"` → 只要匹配任意一个头信息即可。

> 相比 direct、fanout、topic 这些基于 routingKey 的交换机，Headers 更灵活，但性能较低，适合特殊业务场景。

------

### 2️⃣ Consumer 端绑定示例

```java
Map<String, Object> headers = new HashMap<>();
headers.put("x-match","any");       // 匹配方式: all 或 any
headers.put("loglevel", "info");    // 消费者感兴趣的头信息
headers.put("buslevel", "product");
headers.put("syslevel", "admin");

Connection connection = RabbitMQUtil.getConnection();
Channel channel = connection.createChannel();

// 声明 headers 类型的 exchange
channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.HEADERS);

// 声明队列
String queueName = channel.queueDeclare("ReceiverHeader", true, false, false, null).getQueue();

// 将队列绑定到交换机，带上 headers
channel.queueBind(queueName, EXCHANGE_NAME, "", headers);
```

- 注意 `routingKey` 在 headers 模式下不被用作路由，但 API 仍然要求传入，可以留空或存放其他业务信息。
- 队列绑定时，指定的头信息会告诉交换机哪些消息需要路由到这个队列。

------

### 3️⃣ Producer 端发送示例

```java
Map<String, Object> headers = new HashMap<>();
headers.put("loglevel", "error");
headers.put("buslevel", "product");
headers.put("syslevel", "admin");

String message = "LOG INFO asdfasdf";

Connection connection = RabbitMQUtil.getConnection();
Channel channel = connection.createChannel();

// 声明 headers 类型的 exchange
channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.HEADERS);

// 构建消息属性
AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder(); 
builder.deliveryMode(MessageProperties.PERSISTENT_TEXT_PLAIN.getDeliveryMode());
builder.priority(MessageProperties.PERSISTENT_TEXT_PLAIN.getPriority());
builder.headers(headers);

// 发布消息到 exchange
channel.basicPublish(EXCHANGE_NAME, "ourTestRoutingKey", builder.build(), message.getBytes("UTF-8"));

channel.close();
connection.close();
```

- 消息通过 `builder.headers(headers)` 携带头信息。
- 消费者绑定时匹配的头信息决定了消息是否路由到该队列。

------

### 4️⃣ 使用场景

- 消息路由逻辑需要根据 **多维度属性** 来匹配，而不仅仅是字符串 routingKey。
- 适合日志系统、权限消息分发、策略路由等场景。
- 不适合高吞吐量或大规模消息场景，因为性能比 direct/topic/fanout 差。

------

💡 **总结**：

1. Headers 交换机使用 **键值对匹配** 路由消息，而非 routingKey。
2. `"x-match"` 决定 **all/any** 匹配策略。
3. 消费者在绑定队列时指定自己关心的头信息。
4. Producer 在发送消息时携带头信息。
5. 性能低于其他交换机，不适合大规模使用。

# 四、SpringBoot集成RabbitMQ

## 1️⃣ 引入依赖

Spring Boot 官方提供了 RabbitMQ 的 Starter，只需要在 `pom.xml` 中引入：

```
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

- **核心作用**：自动帮你导入 RabbitMQ 客户端库和 Spring AMQP 封装库。
- **注意**：不同版本 Spring Boot 对应的 RabbitMQ 配置方式可能略有不同，尤其是 Spring Boot 3.x 和 2.x 在默认序列化、消息确认机制等上有差异。

------

## 2️⃣ 配置关键参数

在 `application.properties` 或 `application.yml` 中配置 RabbitMQ 的基础参数，例如：

```java
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
```

- 所有配置项都以 `spring.rabbitmq` 开头。
- 生产者、消费者、连接池、模板等的默认行为都可以在这里配置。
- 详细参数可以参考 `RabbitProperties` 类源码或官方 GitHub：[spring-amqp](https://github.com/spring-projects/spring-amqp?utm_source=chatgpt.com)。

------

## 3️⃣ 声明 Exchange、Queue 和 Binding

Spring Boot 中声明这些对象不需要像原生 API 一样手动调用 `channel.exchangeDeclare` 或 `channel.queueDeclare`。
 可以通过 **Bean 声明** 的方式自动创建：

```java
@Bean
public Queue myQueue() {
    return new Queue("myQueue", true); // durable = true
}

@Bean
public DirectExchange myExchange() {
    return new DirectExchange("myExchange");
}

@Bean
public Binding binding(Queue myQueue, DirectExchange myExchange) {
    return BindingBuilder.bind(myQueue).to(myExchange).with("routingKey");
}
```

- **特点**：
  - Spring 容器启动时，会自动检查 RabbitMQ 中是否存在对应对象，如果不存在就创建。
  - 可以绑定已有的队列和交换机，通过 `spring.rabbitmq.*` 配置或 Bean 注入控制。

------

## 4️⃣ 使用 `RabbitTemplate` 发送消息

Spring Boot 会自动初始化 `RabbitTemplate`，发送消息直接使用：

```java
@Autowired
private RabbitTemplate rabbitTemplate;

public void sendMessage(String message) {
    rabbitTemplate.convertAndSend("myExchange", "routingKey", message);
}
```

- `RabbitTemplate` 封装了 RabbitMQ 的原生 API（如 `basicPublish`）。
- 可以设置消息确认、超时、序列化、转换器等属性。

------

## 5️⃣ 使用 `@RabbitListener` 声明消费者

消费者通过注解声明：

```java
@RabbitListener(queues = "myQueue")
public void receiveMessage(String message) {
    System.out.println("Received: " + message);
}
```

- **自动应答**：默认 `ackMode = null`，表示自动应答。
- 可以自定义 `ackMode` 为手动应答、批量应答等。
- Spring Boot 会自动为每个消费者创建 Channel，并管理线程池。

------

## 6️⃣ 核心要点总结

1. Spring Boot 封装了 RabbitMQ 原生 API，开发者无需手动管理 Connection、Channel。
2. 消息发送和消费的模型被统一成 Spring AMQP 的模型（如 `RabbitTemplate`、`Message`），并不是原生 RabbitMQ 对象，但概念上对应。
3. 对于复杂的确认机制、事务、QoS、Headers 交换机等，依然建议理解原生 RabbitMQ API，这样在 Spring Boot 封装之上使用时才不会踩坑。
4. 通过注解、Bean 配置，可以快速完成 Exchange、Queue、Binding 的声明和消息监听。
